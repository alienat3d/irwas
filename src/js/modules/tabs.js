// * 1.0.0 При реализации вкладок (пункты 5 & 7) удобно будет использовать делегирование, т.к. все закладки находятся в некоем общем контейнере, по которому и будет кликать пользователь. На него мы и повесим один обработчик события и дальше внутри будем отслеживать куда именно кликнул пользователь. Это будет куда более экономное к ресурсам пользовательского устройства решением, чем вешать обработчики на каждую закладку. Когда браузер определит куда был сделан клик, то можно будет определить index, т.е. порядковый номер вкладки и на основании этого показан нужный контент. 
// 1.0.1 Также стоит держать в голове, что при клике на разные закладки перемещается также класс активности "after_click". Нужно будет отследить этот класс и при клике на одну из вкладок, у всех убирать, а назначать только той, на которую кликнули в данный момент.
// 1.1 Как и в предыдущем случае с модальными окнами сделаем функцию универсальной с помощью передачи в неё селекторов, которые мы будем использовать: headerSelector (родительский селектор), tabSelector (селектор каждой закладки), contentSelector (селектор для контента) и activeClass (класс активной вкладки).
// 1.2 Получим их всех из вёрстки. Не забываем, что вкладок будет несколько, поэтому логично их получить в живую коллекцию, как в прочем и контент для них.
// 1.3.0 Что касается функционала, нам нужно скрыть все элементы, кроме того, что выбран. Сперва переберём все блоки контента и скроем их.
// 1.3.1 Вторая функция будет наоборот показывать нужный контент и здесь нам уже понадобится индекс, чтобы обращаться к конкретному блоку вёрстки, который требуется показать и он будет привязан к своей вкладке.
// ? 1.3.2 Кстати, если вёрстка будет на флексах, то вкладки могут поехать, чтобы сделать более универсальной функцию можно использовать атрибут isFlex и передавать туда значение, если требуется присваивать свойству display не "block", а "flex". Но пока у нас используется только "block", потому ничего не меняем.
// 1.4.0 Также добавим функционал, добавляющий класс активности на ту вкладку, на которую кликнули (активная). Для этого используем метод перебора forEach() на коллекции вкладок tab. Сперва мы уберём у всех вкладок класс активности.
// 1.4.1 Чтобы загружалась всегда первая вкладка по умолчанию также пропишем index = 0.
// 1.5.1 Теперь будем отслеживать какую вкладку кликнул пользователь, используя делегирование событий. Пропишем header - родительский блок, объединяющий все вкладки. 
// 1.5.2 В этом участке скрипта мы используем много раз evt.target, поэтому удобно поместить его в переменную target. Это будет тот элемент, на котором произошло событие, т.е. в нашем случае куда кликнул пользователь. И вот, как и в любом делегировании нам следует в условии удостовериться, что пользователь кликнул именно туда, куда мы ожидали. В этой проверке нам пригодится метод contains(), который проверит, что перед нами элемент с нужным классом. Внутрь проверки передаём класс вкладки tabSelector. Но так как contains() должен принимать класс без точки, а в tabSelector мы будем подставлять класс с точкой, то нам нужно эту точку вначале обрезать регулярным выражением и методом replace(). Первым аргументом этот метод примет то, что нужно заменить собственно экранированную точку, а вторым на что заменить '' означает ничего\просто удалить.
// 1.5.3 Но ведь пользователь может кликнуть не только в саму вкладку, но и в какой-то её дочерний элемент. И здесь допишем ещё одно условие, которое проверит, что этот элемент относится к нашему tabSelector. И проверять будем не у самого элемента, а у его родительского элемента через parentNode.
// 1.5.4 Теперь, когда мы в этом удостоверились, нам нужно узнать какой индекс у этой вкладки. В этом снова поможет метод forEach() с дополнительном аргументом индекса. Также пропишем условие, что если тот элемент, по которому кликнул пользователь соответствует тому, что перебирается в методе forEach() или его родительский элемент соответствует, то мы используем его индекс. И мы снова вызываем hideTabContent();, скрывая весь контент, а потом подставляем index в showTabContent(index);, показывая только тот контент, который соответствует только что кликнутой вкладке.
const tabsFunc = (headerSelector, tabSelector, contentSelector, activeClass) => {
  const header = document.querySelector(headerSelector),
    tab = document.querySelectorAll(tabSelector),
    content = document.querySelectorAll(contentSelector);

  const hideTabContent = () => {
    content.forEach(block => block.style.display = 'none');
    tab.forEach(tab => tab.classList.remove(activeClass));
  };

  const showTabContent = (index = 0) => {
    content[index].style.display = 'block';
    tab[index].classList.add(activeClass);
  };

  header.addEventListener('click', (evt) => {
    const target = evt.target;
    if (target && (target.classList.contains(tabSelector.replace(/\./, '')) || target.parentNode.classList.contains(tabSelector.replace(/\./, '')))) {
      tab.forEach((tab, index) => {
        if (target === tab || target.parentNode === tab) {
          hideTabContent();
          showTabContent(index);
        }
      });
    }
  });

  hideTabContent();
  showTabContent();
};

export default tabsFunc;