// ? Прежде, чем приступать к выполнению очередной задачи, лучше сперва составить план того, что нам требуется сделать - проговорить словами, что и за чем идёт и какие операции будут выполняться. Таким образом, даже самая сложная задача покажется довольно простой, когда мы её проговорим.

// * 1.0.0 Итак, у нас есть некий триггер (то, с чем будет взаимодействовать пользователь), в данном случае этим триггером является кнопка "Вызвать замерщика".
// 1.0.1 Далее, после события "click" по кнопке будет показ модального окна с классом "popup_engineer".
// 1.0.2 Также нам нужно отследить действия, которые происходят с крестиком или подложкой модального окна. По сути говоря, это область, которая не входит в контент модального окна. И здесь также мы отслеживаем клики пользователя мышкой на эти два элемента. И когда это происходит мы будем скрывать это модальное окно.
// 1.0.3 Скрывать можно либо изменяя CSS-свойство "display", либо если у нас есть готовые CSS-классы, то меняем эти классы. Предпочтительнее второе, т.к. с классами мы можем также реализовывать различные CSS-анимации.
// * 1.0.0 Как мы заметили, модальных окон у на не одно, а сразу несколько, и поэтому, чтобы каждый раз не прописывать один и тот же алгоритм для каждого из них, мы создадим общий алгоритм, который будет принимать в себя разные аргументы, таким образом он будет универсальным.
// 1.0.1 Создадим функцию bindModal(), которая будет отвечать за привязку модального окна к определённому триггеру и в аргументы запишем trigger (селектор кнопки, по которой пользователь будет кликать), modal (селектор модального окна, которое будет открываться) и close (селектор, который будет закрывать модальное окно, собственно "Х").
// 1.0.2 Т.к. некоторые триггеры у нас являются ссылками, то нужно запретить им стандартное поведение. Но сперва в условии проверяем, что этот элемент существует.
// ? Вообще, такие проверки на evt.target (объект события) делаются не просто так, а по причине того, что некоторые элементы на странице не поддерживают определённые события, некоторые не имеют свойство target и т.д. Конечно это скорее редкость, но всё же лучше это проверять.
// 1.0.3 Сперва пропишем простейшую реализацию просто поменяв элементу модального окна свойство "display".
// 1.0.4 Также допишем очень распространённый для модального окна кусочек кода. Т.к. без него при открытом модальном окне и при скролле мышкой будет скроллиться и вся страница. Обычно это поведение убирают, чтобы скроллилось только модальное окно, а страница сзади замирала, пока оно открыто.
// 1.0.5 Теперь перейдём к закрытию модального окна. Здесь в обработчике события нам уже объект события не нужен и мы делаем обратную операцию.
// 1.0.6 Также нам нужно реализовать, чтобы если пользователь кликнул на область вне нашего модального окна, то оно тоже закроется.
// 1.0.7 Получаем необходимые нам элементы из вёрстки.
// 1.0.8 Вызываем функцию и передаём туда нужные нам элементы.
// 1.1.0 Так как у нас несколько разных триггеров, то имеет смысл найти псевдоколлекцию методом querySelectorAll(), а addEventListener поместить в метод перебора массивов forEach().

// * 2.0 Дорабатываем логику модальных окон, чтобы не случилось бага, когда у нас будут наслаиваться одно модальное окно над другим, как может случиться, например по клику на кнопке "Далее" в модальных окнах калькулятора. Напишем скрипт, чтобы по клику далее или крестику закрывались все открытые модальные окна. Также продумывая UX модальных окон калькулятора, стоит заблокировать закрытие окна по клику вне зоны контента модального окна, конкретно для этого типа окон.
// 2.1 Для начала пометим все модальные окна data-атрибутом "data-modal" в HTML.
// 2.2 Получим все модальные окна в переменную windows, чтобы впоследствии закрыть. Ищем по паттерну ['...'], таким образом это поиск по атрибутам.
// * 3.0 Теперь нам нужно контролировать какое модальное окно будет закрываться по клику на подложку, а какое нет. Для этого добавим ещё один атрибут в функцию clickCloseOverlay со значение по умолчанию "true". Т.о. если мы не передаём этот аргумент, то модальное окно будет закрываться по клику на подложку, пока мы не передадим туда значение false.
// 3.1 Также там, где мы прописывали закрытие модального окна по клику на подложку добавим в условие также этот аргумент.
const modalsFunc = () => {
  const bindModal = (triggerSelector, modalSelector, closeSelector, clickCloseOverlay = true) => {
    const trigger = document.querySelectorAll(triggerSelector),
      modal = document.querySelector(modalSelector),
      close = document.querySelector(closeSelector),
      windows = document.querySelectorAll('[data-modal]'),
      scroll = calcScroll();

    trigger.forEach(btn => {
      btn.addEventListener('click', (evt) => {
        if (evt.target) {
          evt.preventDefault();
        }

        windows.forEach(window => window.style.display = 'none');
        // * 4.7 Ну и теперь, там где мы включаем наше модальное окно, пропишем также всему body margin-right на ширину "scroll". Но следует не забыть и убирать этот отступ при закрытии модальных окон. ↓
        modal.style.display = 'block';
        // document.body.classList.add('modal-open');
        document.body.style.cssText = `
          overflow: hidden;
          margin-right: ${scroll}px;
        `;
      });
    });

    close.addEventListener('click', () => {
      windows.forEach(window => window.style.display = 'none');
      // modal.style.display = 'none';
      // document.body.classList.remove('modal-open');
      document.body.style.cssText = `
        overflow: visible;
        margin-right: 0;
      `;
    });
    // 1.0.9 Скрываем модальное окно по клику на подложке (вне области контента модального окна). Подробнее говоря о том, как это работает: когда мы кликаем вне области контента модального окна, то это и будет родительский элемент из переменной modal, а если внутри области контента модального окна, то уже дочерние, например "form", "input" и т.д. и по клику на них модальное окно закрываться соответственно не будет.
    modal.addEventListener('click', (evt) => {
      if (evt.target === modal && clickCloseOverlay) {
        windows.forEach(window => window.style.display = 'none');
        // modal.style.display = 'none';
        // document.body.classList.remove('modal-open');
        document.body.style.cssText = `
          overflow: visible;
          margin-right: 0;
        `;
      }
    });

    window.addEventListener('keydown', (evt) => {
      if (evt.code === 'Escape') {
        windows.forEach(window => window.style.display = 'none');
        // modal.style.display = 'none';
        // document.body.classList.remove('modal-open');
        document.body.style.cssText = `
          overflow: visible;
          margin-right: 0;
        `;
      }
    });
  };
  // 1.2.0 Также для 10-го пункта ТЗ нам понадобится функция-таймер, чтобы модальное окно всплывало через 180 секунд. Функция будет принимать два аргумента - селектор модального окна и значение таймера
  // FIXME: вернуть перед выкатом на прод.
  // const showModalByTime = (selector, timer) => {
  //   setTimeout(() => {
  //     document.querySelector(selector).style.display = 'block';
  //     document.body.style.overflow = 'hidden';
  //   }, timer);
  // };
  // ? Если б мы делали этот проект на фреймворках, то логичнее было бы рендерить модальные окна калькулятора балконных окон прямо из JS, но здесь работаем с обычной вёрсткой, поэтому приходится прописать все три модальных окна друг за другом.

  // * 4.0 Настало время исправить баг, когда при открытии модальных окон исчезает скроллбар справа и из-за этого весь сайт будто бы прыгает вправо. Мы можем исправить это поведение, добавляя отступ ровно на ширину скроллбара, и желательно найти её программно, т.к. в разных браузерах это значение может быть разным. Этим у нас будет заниматься функция calcScroll().
  // 4.1 Чтобы произвести расчёты нам понадобится div.
  // 4.2 Пропишем ему пару свойств, чтобы этот блок не маячил перед глазами пользователя даже на доли секунды.
  // 4.3 Добавим его в body.
  // 4.4 Теперь собственно к вычислению ширины скроллбара. Для этого мы берём наш div и узнаём его полную ширину (включая scrollbar) свойством offsetWidth и из него вычитаем значение из свойства clientWidth, где находится ширина только самого главного контента, включая padding. Но самое главное, что туда не включается ширина scrollbar. Так мы получим точную ширину самого scrollbar.
  // 4.5 Ну и после измерений нам этот div уже не нужен, можно смело его удалять.
  // 4.6 Теперь запишем в переменную scroll результаты наших измерений. ↑
  const calcScroll = () => {
    let div = document.createElement('div');

    div.style.width = '50px';
    div.style.height = '50px';
    div.style.overflowY = 'scroll';
    div.style.visibility = 'hidden';

    document.body.appendChild(div);

    let scrollWidth = div.offsetWidth - div.clientWidth;

    div.remove();

    return scrollWidth;
  };

  bindModal('.popup_engineer_btn', '.popup_engineer', '.popup_engineer .popup_close');
  bindModal('.phone_link', '.popup', '.popup .popup_close');

  bindModal('.popup_calc_btn', '.popup_calc', '.popup_calc_close');
  bindModal('.popup_calc_button', '.popup_calc_profile', '.popup_calc_profile_close', false);
  bindModal('.popup_calc_profile_button', '.popup_calc_end', '.popup_calc_end_close', false);
  // FIXME: вернуть перед выкатом на прод.
  // showModalByTime('.popup', '180000');
};

export default modalsFunc;