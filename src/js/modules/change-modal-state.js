// * 1.0 Итак начнём работу с состоянием модального окна калькулятора балконного окна, куда мы будем заносить все выбранные и введённые данные пользователем для отправки заказа.
/* 1.1 Далее получим элементы, с которыми будем работать. И у нас есть 5 видов выбора, которые должен сделать пользователь:
  1) форма балкона;
  2) ширина;
  3) высота;
  4) профиль остекления;
  5) холодный или тёплый тип остекления.
*/
// 1.2.0 Теперь методом перебора forEach() переберём наши вкладки форм окна. Здесь нам также пригодится индекс, т.к. когда будет произведён клик по определённому элементу, то его индекс нужно записать в объект state. Т.о. мы сможем сохранить какой вид формы выбрал пользователь.
// 1.2.1 Теперь навесим на каждую вкладку выбора формы окна обработчик события и пропишем в коллбэк-функцию, что в свойство form объекта state будет записываться индекс элемента, по которому кликнули.
// 1.3.0 Теперь нам нужно все оставшееся элементы точно также подвязать к определённым обработчикам события и при взаимодействия пользователя с ними записывать в state-объект как отдельные свойства со значениями. И здесь можно оптимизировать код, ведь здесь будет повторяться один и тот же алгоритм. Потому удобно будет написать одну функцию, которая будет всё это выполнять за нас, а мы будем подставлять разные аргументы.
// 1.3.1 Такой функцией у нас будет bindActionsToElements() и она примет три аргумента: event (то событие, которое нас интересует), element (элемент, на котором будет происходить событие) и property (свойство, которое будет меняться в state-объекте).
// 1.3.2 Продолжаем модернизировать нашу функцию bindActionsToElements(). Дальше нам нужно получить выбор select и checkbox. Обоим этим элементам больше подойдёт событие "change".
// 1.3.3 В калькуляторе мы взаимодействуем с 3-мя видами элементов на странице: <span>, <input> & <select>. Итак, мы можем сперва сделать проверку с каким элементом (нодой) взаимодействует пользователь и уже в зависимости от этого выполнять те или иные действия. Здесь нам пригодится такое свойство, как "nodeName" и этот параметр приходит в виде строки. А мы знаем, что если у нас есть строка и мы хотим её сравнить с многими значениями, то отлично подходит конструкция "switch case". Передадим внутрь строку, которая точно будет знать какая сейчас нужна нода.
// 1.3.4 Также там, где инпуты имеет смысл сделать ещё одно разветвление, т.к. у нас есть два вида инпута, одни чекбоксы, а другие, где пользователь вводит цифры. Поэтому допишем ещё одно условие.
// 1.3.5 Итак, где у нас чекбоксы прописываем тернарный оператор. И если индекс равен 0, то запишем в свойство "Холодное", иначе пропишем "Тёплое". 
// 1.3.6 Также следует прописать так, чтобы пользователь мог выбрать лишь один чекбокс. Возьмём все чекбоксы, которые лежат в element и пройдёмся по ним методом forEach(). Уберём все галочки с чекбоксов, кроме того, на который кликнул пользователь.
// * 1.4.0 Теперь, когда создание state-объекта готово, нам нужно присоединить его к отправке данных из формы, добавив в FormData именно этой формы из калькулятора. Для этого нужно как-то особенно её обозначить.
// 1.4.1 Добавим в HTML к нужной нам форме новый атрибут data-calc="end", чтобы JS мог потом её найти.
// 1.4.2 Теперь снова перейдём в main.js
import checkNumInputsFunc from './check-num-inputs';

const changeModalStateFunc = (state) => {
  const windowForm = document.querySelectorAll('.balcon_icons_img'),
    windowWidth = document.querySelectorAll('#width'),
    windowHeight = document.querySelectorAll('#height'),
    windowType = document.querySelectorAll('#view_type'),
    windowProfile = document.querySelectorAll('.checkbox');

  // ? Итак, если мы будем передавать в element конкретный элемент, то наш скрипт не сработает, т.к. forEach() работает с массивами. И выхода здесь как минимум 2: 1) можно написать условие, которое будет проверять количество элементов в атрибуте element и если там лишь 1 элемент, то мы назначим просто обработчик события, а если там несколько элементов, то это значит, что там массив или живая коллекция, тогда её будем перебирать с помощью forEach(); 2) можно получать все элементы с помощью метода querySelectorAll() и тогда везде будут псевдомассивы. Даже если в псевдомассиве будет 1 элемент, то forEach() всё равно правильно сработает.

  const bindActionsToElements = (event, element, property) => {
    element.forEach((item, index) => {
      item.addEventListener(event, () => {
        switch (item.nodeName) {
          case 'SPAN':
            state[property] = index;
            break;
          case 'INPUT':
            if (item.getAttribute('type') === 'checkbox') {
              index === 0 ? state[property] = 'Холодное' : state[property] = 'Тёплое';
              element.forEach((checkbox, idx) => {
                checkbox.checked = false;
                if (index == idx) {
                  checkbox.checked = true;
                }
              });
            } else {
              state[property] = item.value;
            }
            break;
          case 'SELECT':
            state[property] = item.value;
            break;
        }
        console.log(state);
      });
    });
  };

  /* windowForm.forEach((choice, index) => {
    choice.addEventListener('click', () => {
      state.form = index;
    });
  }); */

  checkNumInputsFunc('#width');
  checkNumInputsFunc('#height');
  bindActionsToElements('click', windowForm, 'form');
  bindActionsToElements('input', windowWidth, 'width');
  bindActionsToElements('input', windowHeight, 'height');
  bindActionsToElements('change', windowType, 'type');
  bindActionsToElements('change', windowProfile, 'profile');
};

export default changeModalStateFunc;