/*  1.0.0 Прежде, чем писать наш собственный таймер продумаем весь алгоритм:
  1) Изначально нам понадобится функция, которая будет определять количество времени, оставшееся до окончания нашего дедлайна;
  2) Эта функция будет принимать определённые данные, которые мы установим, вычислять остаток и потом из этого остатка составлять количество секунд, минут, часов и дней;
  3) Также нам понадобится функция, которая будет устанавливать таймер. Она будет содержать в себе элементы, которые будут располагать данными, которые придут из первой функции. Т.е. в какой элемент вставить кол-во секунда, минут и т.д.;
  4) Кроме этого она циклично будет запускать ещё одну функцию, которая будет обновлять в ней время. Т.е. эта функция будет каждую секунду вычислять остаток до дедлайна и обновлять данные на странице.
*/
// 1.0.1 В аргументах у нас будет селектор самого элемента с таймером и дедлайн.
// 1.1.0 Первой функцией будет getTimeRemaining() — она будет принимать значение deadline и выдавать оставшееся количество времени до него.
// 1.1.1 Создадим внутри переменную t (от. "time"). Сюда нам нужно получить разницу между переданным временем дедлайна и тем временем, что у нас сейчас. Но время в JS исчисляется миллисекундами, поэтому сначала мы приведём всё к единому множителю, а потом уже будем делать исчисления.
// 1.1.2 Запишем объект Date и его метод parse(), т.о. мы получим строку с датой в определённом формате. И после определённых манипуляций внутри он вернёт количество миллисекунд, которое прошло с 1 января 1970 года. И от этого количества времени нужно отнять количество до текущего момента Date.parse(new Date()).
// 1.1.3 Дальше нам нужно при помощи математических исчислений найти секунды, минуты, часы и дни. И вот в секундах у нас будет именно остаток секунд, после исчисления полных минут. Т.е. сначала мы миллисекунды переведём в секунды / 1000, а потом применим модуль (деления с остатком) на 60. Также не забудем округлять полученные данные.
// 1.1.4 По похожему принципу находим и минуты, делим общее количество миллисекунд на (1000 * 60), тем самым получим общее кол-во минут и делим с остатком на 60, для отображения лишнего остатка, после высчитывания часов.
// 1.1.5 Также получаем общее кол-во часов (1000 * 60 * 60), а потом делим на 24 с остатком, чтобы найти оставшиеся часы, после исчисления всех дней, т.к. в одних сутках у нас 24 часа.
// 1.1.6 Ну, а чтобы найти количество всех дней делим общее кол-во миллисекунда на (1000 * 60 * 60 * 24).
// 1.1.7 Когда у нас посчитано всё, что нужно, то можем эти данные из функции вернуть и сделать это будет более удобно в виде объекта.
const timerFunc = (selector, deadline) => {
  // * 1.3.0 Однако осталось ещё кое-что, дело в том, что когда у нас значения будут < 10, то по умолчанию 0 перед ними не будет, а в задании он должен быть. Чтобы это исправить напишем ещё одну вспомогательную функцию.
  // 1.3.1 Аргументом она примет число и создадим простое условие, где будет прописано, что если число будет < 10, то возвращаем его вместе с 0 перед ним. Теперь мы можем её использовать в функции updateClock(). ↓
  const addZero = (num) => {
    if (num < 10) {
      return '0' + num;
    }
    return num;
  };
  // * [fixed] Добавил в расчёт t поправку на разницу во времени между локальным и UTC при помощи метода getTimezoneOffset() который получает разницу в минутах.
  const getTimeRemaining = (endtime) => {
    const t = (Date.parse(endtime) + (new Date().getTimezoneOffset() * 60 * 1000)) - Date.parse(new Date()),
      seconds = Math.round((t / 1000) % 60),
      minutes = Math.round((t / (1000 * 60)) % 60),
      hours = Math.round((t / (1000 * 60 * 60)) % 24),
      days = Math.round((t / (1000 * 60 * 60 * 24)) - 1);

    return {
      'total': t,
      'seconds': seconds,
      'minutes': minutes,
      'hours': hours,
      'days': days,
    };
  };
  // * 1.2.0 Переходим к следующей функции setClock(), которая будет отвечать за то, чтобы помещать значения в определённые места вёрстки.
  // 1.2.1 Внутри получим нужные нам элементы.
  // 1.2.2 Также нам понадобится специальная переменная timeInterval, в которой будет хранится ID таймера, чтобы можно было его очистить по истечении времени. В неё передадим setInterval(), а аргументом будет функция обновления результата таймера updateClock, которая будет запускаться каждую секунду.
  const setClock = (selector, endtime) => {
    const timer = document.querySelector(selector),
      secondsElem = timer.querySelector('#seconds'),
      minutesElem = timer.querySelector('#minutes'),
      hoursElem = timer.querySelector('#hours'),
      daysElem = timer.querySelector('#days'),
      timeInterval = setInterval(updateClock, 1000);

    updateClock(); // один раз вызовем функцию, чтоб
    // 1.2.3 Эта функция определяет сколько времени осталось до дедлайна.
    // 1.2.4 Теперь записываем в контент каждого из элементов значение из объекта расчёта времени, который мы создавали в getTimeRemaining().
    // 1.2.5 Нам также нужно позаботится о том, что будет, когда таймер закончится. Во-первых, в значениях должны везде стоять 0, а во-вторых, нам нужно очистить интервал, чтобы не было утечек памяти. Для этого напишем условие и обратимся к свойству объекта t "total" и запишем, что если оно стало 0 или меньше, то мы все значения таймера в вёрстке установим по нулям.
    // 1.2.6 Чтобы очистить интервал пишем команду clearInterval(), а аргументом будет ID интервала таймера.
    function updateClock() {
      const t = getTimeRemaining(endtime);

      secondsElem.textContent = addZero(t.seconds);
      minutesElem.textContent = addZero(t.minutes);
      hoursElem.textContent = addZero(t.hours);
      daysElem.textContent = addZero(t.days);

      if (t.total <= 0) {
        secondsElem.textContent = '00';
        minutesElem.textContent = '00';
        hoursElem.textContent = '00';
        daysElem.textContent = '00';

        clearInterval(timeInterval);
      }
    }
  };

  setClock(selector, deadline);
};

export default timerFunc;