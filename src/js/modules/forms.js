// * 1.0 В принципе все формы у нас в этом проекте одинаковы, они просто собирают информацию внутри себя и отправляют на сервер. Сложного функционала в них нет.
// 1.1 Нам нужно получить из вёрстки все формы, что есть на странице и строки ввода, что есть внутри этих форм. А затем навесим обработчик события на все формы.
// 1.2 Также имеет смысл как-то оповещать пользователя об успешности отправления его заявки на сервер. Для этого создадим отдельно переменную message.
// 1.3.0 Переходим к реализации логики. С помощью метода forEach() переберём все формы и на каждую из них повесим обработчик события "submit".
// 1.3.1 Зачем нам здесь объект события? Дело в том, что по стандарту, когда мы отправляем форму со страницы на сервер — она перезагружается и нам следует отменить это поведение, т.к. в ТЗ сказано, что формы должны уходить на сервер без перезагрузки при помощи AJAX. И неотъемлемой частью кода AJAX является отмена такого поведения браузера.
// 1.4.0 Теперь нам нужно создать блок, где мы будем размещать сообщения пользователю об успешности отправки. Он будет создаваться при помощи скрипта только во время отправки формы.
// 1.4.1 Чтобы слегка приукрасить форму добавим класс "status" и поместим этот блок в конец формы при помощи appendChild().
// 1.5.0 Теперь необходимо собрать все данные, что есть у нас в форме. Сделаем это при помощи объекта formData. Этот специальный объект найдёт все инпуты, соберёт данные в специальную структуру и мы поместит её в переменную formData. 
// ? При помощи FormData можно загружать всё, что угодно. Туда попадут и изображения и файлы, которые можно прикрепить к сообщению.
// 1.5.1 И здесь есть один нюанс: в некоторых случаях мы могли бы отправить на сервер данные в виде FormData, но нам нужно удостовериться, что сервер принимает такие данные. Может ему будет необходим стандартный формат URL-encoded, а может JSON. В зависимости от этого мы будем отправлять запросы по разному.
// 1.5.2 Теперь напишем сам запрос. Запишем её в виде стрелочной функции в переменной postData.
// 1.5.3 И перед тем, как отправить сам запрос, логично было бы сообщить пользователю, что идёт загрузка. Найдём наш блок для сообщений и вставим в него текст, что идёт загрузка.
// ? Зачем мы вынесли отправку запроса в отдельную функцию, когда можно было записать запрос fetch() прям в переборе форм forEach()? Так мы скроем некоторую реализацию, например, fetch API на самом деле вернёт promise. И этот promise мы должны ещё раз обработать. Т.е. вернуть либо JSON формат, либо текстового файла. И возможно этот функционал понадобится в будущем ещё.
// 1.5.4 Итак в переменную resp (response) поместим метод запроса на сервер fetch(). Также нам понадобятся атрибуты url (адрес сервера, куда будем слать запросы) и data (передаваемые данные).
// 1.5.5 Т.к. отправляем FormData, то заголовок ставить не будем.
// 1.5.6 Запишем запрос с реализацией через async await. (Хотя можно и через then()). Теперь кода будет выполняться дальше, только после того, как отработает до конца запрос fetch.
// 1.5.7 Т.к. text() у нас тоже асинхронная операция, нам следует также написать await, чтобы JS сперва дожидался её выполнения, а уже потом возвращал данные из функции.
// * 2 Так как удалять всё, кроме цифр из строки ввода нам требуется сразу в нескольких местах, то мы вынесли эту валидацию в [check-num-inputs.js]. Теперь её нужно сюда оттуда подключить.
// * 3.0 Передадим в главную функцию formsFunc() атрибутом state-объект. Хотя использоваться он будет только в единичном случае, когда мы будем отправлять данные из нашего popup-калькулятора. Перейдём к FormData ↓
import checkNumInputsFunc from './check-num-inputs';

const formsFunc = (state) => {
  const forms = document.querySelectorAll('form'),
    inputs = document.querySelectorAll('input');

  const message = {
    loading: 'Идёт загрузка...',
    success: 'Заявка успешно отправлена! Скоро с вами свяжется наш консультант.',
    failure: 'Просим прощения, но что-то пошло не так, попробуйте отправить заявку снова.'
  };

  const postData = async (url, data) => {
    document.querySelector('.status').textContent = message.loading;

    let resp = await fetch(url, {
      method: 'POST',
      body: data
    });

    return await resp.text();
  };

  const clearInputs = () => {
    inputs.forEach(input => {
      input.value = '';
    });
  };

  forms.forEach(form => {
    form.addEventListener('submit', (evt) => {
      evt.preventDefault();

      let statusMessage = document.createElement('div');
      statusMessage.classList.add('status');
      form.appendChild(statusMessage);
      const formData = new FormData(form);
      // * 3.1 Создадим условие, что если у формы, которую браузер собирается отправить есть определённый атрибут, то мы добавим ещё данные из state-объекта в довесок. Если условие выполняется, то мы берём state-объект и разбираем с помощью "for...in" на отдельные ключи и значения. И вот каждые эти пары мы будем добавлять методом append() в FormData. У этого метода есть два аргумента первый будет ключом (key), а второй значением (state[key]).
      if (form.getAttribute('data-calc') === 'end') {
        for (let key in state) {
          formData.append(key, state[key]);
        }
      }

      // 1.6.0 Передаём в url файл сервера и данные, которые мы отправляем на сервер. Далее в методе then(), который срабатывает после получения ответа с сервера запишем response (resp) и здесь также уведомим пользователя сообщением.
      // 1.6.1 Не забудем обработать возможную ошибку в блоке кода catch().
      // 1.6.2 В блок кода finally() поместим функционал очистки инпутов. Ну и здесь же сообщение statusMessage требуется удалить через определённое время. Функционал очистки инпутов лучше даже вынести в отдельную функцию clearInputs.
      postData('assets/server.php', formData)
        .then(resp => {
          console.log(resp);
          statusMessage.textContent = message.success;
        })
        .catch(() => {
          statusMessage.textContent = message.failure;
        })
        .finally(() => {
          clearInputs();
          setTimeout(() => {
            statusMessage.remove();
          }, 7000);
        });
      // ? Ещё одно уточнение: если бы у нас было больше запросов, например разные POST-запросы или ещё GET-запросы, то имело бы смысл создать дополнительный файл services.js, куда поместить эти запросы и импортировать их потом сюда.
    });
  });

  // 1.7.0 Ещё нам нужно по ТЗ сделать так, чтобы поля телефона можно было вписать лишь цифры. Конечно можно было бы реализовать это в HTML type="phone", но не всегда есть доступ к HTML, к тому же сами инпуты могут быть в виде div'ов и нужно уметь делать такую валидацию в таких случаях.
  // 1.7.1 Самый простой способ проверить текстовое значение — регулярное выражение, с помощью него мы можем отследить что вводит пользователь и если эти символы не соответствуют нашим критериям, то мы их просто удаляем. Соответственно здесь мы удалим все символы, которые будут не числами. При помощи метода строк replace() мы фильтруем регулярным выражением значение input, удаляем из него всё, кроме чисел и возвращаем обратно.
  checkNumInputsFunc('input[name="user_phone"]');
  // todo код ниже перенесён в check-num-inputs.js, а от переменной мы избавились, поместив в функцию сам селектор.
  /* phoneInputs.forEach(input => {
    input.addEventListener('input', () => {
      input.value = input.value.replace(/\D/, '');
    });
  }); */
};

export default formsFunc;